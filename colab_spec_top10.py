# -*- coding: utf-8 -*-
"""colab_spec_top10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a8MxAOKFsoSBMaI1D5HDk5XCOzxezK4b

# ğŸ“ˆ Colab: íˆ¬ê¸°ìœ„í—˜ Top10 ì‚°ì¶œ & Â±6ê°œì›” ì¶”ì´

ë‘ CSV(ê±°ë˜ëŸ‰ì§€í‘œ, ê°€ê²©ì§€ìˆ˜)ë¡œ ê¸°ì¤€ì›” ì „ 6ê°œì›” í‰ê·  ëŒ€ë¹„ ì¦ê°€ìœ¨ì„ ê³„ì‚°í•˜ê³ , íˆ¬ê¸°ìœ„í—˜ í™˜ì‚°ì¹˜ = (ê±°ë˜ëŸ‰Ã—3 + ê°€ê²©ì§€ìˆ˜Ã—7)/10 ì„ ì‚°ì¶œí•œ ë’¤, Top10 ë° Â±6ê°œì›” ì¶”ì´ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.
"""

!pip -q install pandas numpy python-dateutil xlsxwriter

import pandas as pd
import numpy as np
from datetime import datetime
from dateutil.relativedelta import relativedelta

def ym_to_col(ym: str) -> str:
    d = datetime.strptime(ym, "%Y-%m")
    return f"{d.year}ë…„ {d.month}ì›”"

def prev_month_columns(ym: str, n: int) -> list:
    d = datetime.strptime(ym, "%Y-%m")
    cols = []
    for i in range(n-1, -1, -1):
        di = d - relativedelta(months=i)
        cols.append(f"{di.year}ë…„ {di.month}ì›”")
    return cols

def around_month_columns(ym: str, n: int) -> list:
    d = datetime.strptime(ym, "%Y-%m")
    cols = []
    for i in range(-n, n+1):
        di = d + relativedelta(months=i)
        cols.append(f"{di.year}ë…„ {di.month}ì›”")
    return cols

def normalize_sido(name: str) -> str:
    if not isinstance(name, str):
        return name
    name = name.strip()
    keys = ["ì„œìš¸","ë¶€ì‚°","ëŒ€êµ¬","ì¸ì²œ","ê´‘ì£¼","ëŒ€ì „","ìš¸ì‚°","ì„¸ì¢…",
            "ê²½ê¸°","ê°•ì›","ì¶©ë¶","ì¶©ë‚¨","ì „ë¶","ì „ë‚¨","ê²½ë¶","ê²½ë‚¨","ì œì£¼"]
    for k in keys:
        if name.startswith(k):
            return k
    for k in keys:
        if k in name:
            return k
    return name

def read_korean_csv(file_or_path):
    try:
        return pd.read_csv(file_or_path)
    except Exception:
        return pd.read_csv(file_or_path, encoding="euc-kr")

def load_trade(trade_path_or_buf):
    df = read_korean_csv(trade_path_or_buf)
    if "No" in df.columns:
        df = df[~df["No"].astype(str).str.fullmatch("No", na=False)].copy()
    if "ì§€ì—­.1" in df.columns:
        df["í†µí•©ì§€ì—­"] = df["ì§€ì—­"].astype(str).str.strip() + " " + df["ì§€ì—­.1"].astype(str).str.strip()
    else:
        df["í†µí•©ì§€ì—­"] = df["ì§€ì—­"].astype(str).str.strip()
    month_cols = [c for c in df.columns if ("ë…„" in c and ".1" not in c)]
    for c in month_cols:
        df[c] = pd.to_numeric(df[c].astype(str).str.replace('"','').str.replace(',', ''), errors="coerce")
    return df, month_cols

def load_price(price_path_or_buf):
    df = read_korean_csv(price_path_or_buf)
    if "ì§€ì—­" not in df.columns:
        for cand in df.columns:
            if "ì§€ì—­" in cand:
                df = df.rename(columns={cand:"ì§€ì—­"})
                break
    month_cols = [c for c in df.columns if ("ë…„" in c)]
    for c in month_cols:
        df[c] = pd.to_numeric(df[c], errors="coerce")
    return df, month_cols

def compute_growths_for_month(trade_df, price_df, target_ym: str, window=6, weight_vol=3, weight_price=7):
    win_cols = prev_month_columns(target_ym, window)
    win_cols = [c for c in win_cols if (c in trade_df.columns and c in price_df.columns)]
    if len(win_cols) < 1:
        raise ValueError("ê³µí†µ ì›” ì»¬ëŸ¼ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.")
    rows = []
    for _, r in trade_df.iterrows():
        sido = str(r["ì§€ì—­"]).strip() if "ì§€ì—­" in r else ""
        region_full = r["í†µí•©ì§€ì—­"]
        # ê±°ë˜ëŸ‰
        tvals = [r.get(c, None) for c in win_cols]
        tcurr = tvals[-1] if tvals else None
        tma = pd.Series(tvals).mean(skipna=True) if tvals else None
        trat = float(tcurr)/tma if (tcurr and tma and tma!=0 and pd.notna(tcurr) and pd.notna(tma)) else np.nan
        # ê°€ê²©ì§€ìˆ˜
        pmatch = price_df[price_df["ì§€ì—­"].astype(str).str.contains(str(region_full), na=False)]
        if pmatch.empty:
            pmatch = price_df[price_df["ì§€ì—­"].apply(normalize_sido)==normalize_sido(sido)]
        if pmatch.empty:
            pvals = [np.nan]*len(win_cols)
        else:
            p = pmatch.iloc[0]
            pvals = [p.get(c, np.nan) for c in win_cols]
        pcurr = pvals[-1] if pvals else None
        pma = pd.Series(pvals).mean(skipna=True) if pvals else None
        prat = float(pcurr)/pma if (pcurr and pma and pma!=0 and pd.notna(pcurr) and pd.notna(pma)) else np.nan
        spec = (weight_vol*(trat if pd.notna(trat) else 0.0) + weight_price*(prat if pd.notna(prat) else 0.0)) / (weight_vol+weight_price)
        rows.append({
            "ì§€ì—­": sido, "í†µí•©ì§€ì—­": region_full, "ê¸°ì¤€ì›”": target_ym,
            "ê±°ë˜ëŸ‰(ê¸°ì¤€ì›”)": tcurr, "ê±°ë˜ëŸ‰(6Mí‰ê· )": tma, "ê±°ë˜ëŸ‰_ì¦ê°€ìœ¨(ê¸°ì¤€/6M)": trat,
            "ê°€ê²©ì§€ìˆ˜(ê¸°ì¤€ì›”)": pcurr, "ê°€ê²©ì§€ìˆ˜(6Mí‰ê· )": pma, "ê°€ê²©ì§€ìˆ˜_ì¦ê°€ìœ¨(ê¸°ì¤€/6M)": prat,
            "íˆ¬ê¸°ìœ„í—˜í™˜ì‚°ì¹˜": spec
        })
    return pd.DataFrame(rows)

def extract_window_tables(trade_df, price_df, region_list, center_ym: str, half_window=6):
    cols = around_month_columns(center_ym, half_window)
    cols = [c for c in cols if (c in trade_df.columns or c in price_df.columns)]
    out = {}
    for reg in region_list:
        tr = trade_df[trade_df["í†µí•©ì§€ì—­"]==reg]
        if tr.empty:
            continue
        tr = tr.iloc[0]
        trade_row = {c: tr[c] if c in trade_df.columns else np.nan for c in cols}
        pr = price_df[price_df["ì§€ì—­"].astype(str).str.contains(str(reg), na=False)]
        if pr.empty:
            sido = str(tr["ì§€ì—­"]) if "ì§€ì—­" in tr else ""
            pr = price_df[price_df["ì§€ì—­"].apply(normalize_sido)==normalize_sido(sido)]
        if not pr.empty:
            pr = pr.iloc[0]
            price_row = {c: pr[c] if c in price_df.columns else np.nan for c in cols}
        else:
            price_row = {c: np.nan for c in cols}
        df = pd.DataFrame([ [trade_row.get(c, np.nan) for c in cols],
                            [price_row.get(c, np.nan) for c in cols] ],
                          index=["ê±°ë˜ëŸ‰","ê°€ê²©ì§€ìˆ˜"], columns=cols).reset_index().rename(columns={"index":"í•­ëª©"})
        out[reg] = df
    return out

"""## 1) íŒŒì¼ ì—…ë¡œë“œ"""

from google.colab import files
print('ê±°ë˜ëŸ‰ì§€í‘œ íŒŒì¼ ì—…ë¡œë“œ: (ì›”) í–‰ì •êµ¬ì—­ë³„ ì•„íŒŒíŠ¸ê±°ë˜ëŸ‰ì§€í‘œ.csv')
uploaded1 = files.upload()
print('ê°€ê²©ì§€ìˆ˜ íŒŒì¼ ì—…ë¡œë“œ: (ì›”) í–‰ì •êµ¬ì—­ë³„ ì•„íŒŒíŠ¸ê°€ê²©ì§€ìˆ˜.csv')
uploaded2 = files.upload()
trade_path = list(uploaded1.keys())[0]
price_path = list(uploaded2.keys())[0]
trade_df, trade_months = load_trade(trade_path)
price_df, price_months = load_price(price_path)
print('ì—…ë¡œë“œ ì™„ë£Œ!')
print('ì˜ˆì‹œ ê³µí†µì›”:', sorted(list(set(trade_months).intersection(price_months)))[:5])

"""## 2) ê¸°ì¤€ì›”/íŒŒë¼ë¯¸í„° ì„¤ì •"""

target_ym = input('ê¸°ì¤€ ì—°ì›”(YYYY-MM), ë¯¸ì…ë ¥ ì‹œ ê³µí†µ ìµœê·¼ì›” ìë™ ì„ íƒ: ').strip()
if not target_ym:
    def _parse(col):
        y = int(col.split('ë…„')[0]); m = int(col.split('ë…„')[1].replace('ì›”','').strip()); return (y,m)
    common = sorted(list(set(trade_months).intersection(price_months)), key=_parse)
    latest = common[-1]
    target_ym = f"{latest.split('ë…„')[0].strip()}-{latest.split('ë…„')[1].replace('ì›”','').strip().zfill(2)}"
print('ê¸°ì¤€ì›”:', target_ym)
window = 6
w_vol, w_price = 3, 7

"""## 3) ê³„ì‚° ì‹¤í–‰ ë° ì €ì¥"""

metrics = compute_growths_for_month(trade_df, price_df, target_ym, window, w_vol, w_price)
metrics = metrics.sort_values('íˆ¬ê¸°ìœ„í—˜í™˜ì‚°ì¹˜', ascending=False)
top10 = metrics.head(10).copy()
display(top10)
metrics_path = f'ì¦ê°€ìœ¨_ë°_íˆ¬ê¸°ìœ„í—˜_{target_ym}.csv'
metrics.to_csv(metrics_path, index=False, encoding='utf-8-sig')
print('ì €ì¥:', metrics_path)

"""## 4) ìƒìœ„ 10ê°œ ì§€ì—­ Â±6ê°œì›” ì¶”ì´ Excel ìƒì„±"""

win_tables = extract_window_tables(trade_df, price_df, top10['í†µí•©ì§€ì—­'].tolist(), target_ym, 6)
writer_path = f'ìƒìœ„10_Â±6ê°œì›”_ì¶”ì´_{target_ym}.xlsx'
with pd.ExcelWriter(writer_path, engine='xlsxwriter') as writer:
    for reg, df in win_tables.items():
        sheet = reg.replace('/', '_')[:30]
        df.to_excel(writer, sheet_name=sheet, index=False)
print('ì €ì¥:', writer_path)